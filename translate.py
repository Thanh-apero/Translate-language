# -*- coding: utf-8 -*-
"""translate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_b5pa6glkUTaWFIr_VzUwaCGDT0_FLL9
"""



import json
import google.generativeai as genai

api_keys = [
    "AIzaSyB_59fjCUN_vGW8FnPf5CZdl267_yfiOBs",
    "AIzaSyCN7x2uMvL2cHq0jdBq9aMJ9ijJYct4QJ0"
]
current_key_index = 0  # Chỉ mục để theo dõi key hiện tại

# Định nghĩa cấu hình sinh nội dung
generation_config = {
    "temperature": 1,
    "top_p": 0.95,
    "top_k": 40,
    "max_output_tokens": 8192,
    "response_mime_type": "text/plain",
}

def get_next_api_key():
    """Luân phiên API key mỗi lần gọi"""
    global current_key_index
    key = api_keys[current_key_index]
    current_key_index = (current_key_index + 1) % len(api_keys)  # Xoay vòng
    return key

def request(input_data):

    genai.configure(api_key=get_next_api_key())
    model = genai.GenerativeModel(
        model_name="gemini-2.0-flash",
        generation_config=generation_config,
    )
    response = model.generate_content([
        "input: {\n  \"source_language\": \"en\",\n  \"target_language\": \"ko\",\n  \"strings\": [\n    {\"id\": 1, \"text\": \"Your document has been saved successfully.\"},\n    {\"id\": 2, \"text\": \"Please check your internet connection and try again.\"},\n    {\"id\": 3, \"text\": \"This feature is not available in the free version.\"}\n  ]\n}",
        "output: {\n  \"translations\": [\n    {\"id\": 1, \"text\": \"문서가 성공적으로 저장되었습니다.\"},\n    {\"id\": 2, \"text\": \"인터넷 연결을 확인하고 다시 시도하세요.\"},\n    {\"id\": 3, \"text\": \"이 기능은 무료 버전에서 사용할 수 없습니다.\"}\n  ]\n}",
        "input: {\n  \"source_language\": \"en\",\n  \"target_language\": \"ko\",\n  \"strings\": [\n    {\"id\": 1, \"text\": \"Don’t forget to write tag #XpertScan\"},\n    {\"id\": 2, \"text\": \"Can't find an app that supports this action\"}\n  ]\n}",
        "output: {\n  \"translations\": [\n    {\"id\": 1, \"text\": \"#XpertScan 태그를 작성하는 것을 잊지 마세요\"},\n    {\"id\": 2, \"text\": \"이 작업을 지원하는 앱을 찾을 수 없습니다\"}\n  ]\n}",
        "input: {\n  \"source_language\": \"en\",\n  \"target_language\": \"zh\",\n  \"strings\": [\n    {\"id\": 1, \"text\": \"Export as PDF failed\"},\n    {\"id\": 2, \"text\": \"Share as PDF failed\"},\n    {\"id\": 3, \"text\": \"Export to gallery failed\"},\n    {\"id\": 4, \"text\": \"Share as picture failed\"},\n    {\"id\": 5, \"text\": \"Print PDF failed\"},\n    {\"id\": 6, \"text\": \"Insert password\"}\n  ]\n}",
        "output: {\n  \"translations\": [\n    {\"id\": 1, \"text\": \"导出为PDF失败\"},\n    {\"id\": 2, \"text\": \"分享为PDF失败\"},\n    {\"id\": 3, \"text\": \"导出到图库失败\"},\n    {\"id\": 4, \"text\": \"分享为图片失败\"},\n    {\"id\": 5, \"text\": \"打印PDF失败\"},\n    {\"id\": 6, \"text\": \"请输入密码\"}\n  ]\n}",
        "input: {\n  \"source_language\": \"en\",\n  \"target_language\": \"vi\",\n  \"strings\": [\n    {\"id\": 1, \"text\": \"Export as PDF failed\"},\n    {\"id\": 2, \"text\": \"Share as PDF failed\"},\n    {\"id\": 3, \"text\": \"Export to gallery failed\"},\n    {\"id\": 4, \"text\": \"Share as picture failed\"},\n    {\"id\": 5, \"text\": \"Print PDF failed\"},\n    {\"id\": 6, \"text\": \"Insert password\"}\n  ]\n}",
        "output: {\n  \"translations\": [\n    {\"id\": 1, \"text\": \"Xuất PDF thất bại\"},\n    {\"id\": 2, \"text\": \"Chia sẻ dưới dạng PDF thất bại\"},\n    {\"id\": 3, \"text\": \"Xuất vào thư viện thất bại\"},\n    {\"id\": 4, \"text\": \"Chia sẻ dưới dạng hình ảnh thất bại\"},\n    {\"id\": 5, \"text\": \"In PDF thất bại\"},\n    {\"id\": 6, \"text\": \"Nhập mật khẩu\"}\n  ]\n}",
        "input: {\n  \"source_language\": \"en\",\n  \"target_language\": \"it\",\n  \"strings\": [\n    {\"id\": 1, \"text\": \"Export as PDF failed\"},\n    {\"id\": 2, \"text\": \"Share as PDF failed\"},\n    {\"id\": 3, \"text\": \"Export to gallery failed\"},\n    {\"id\": 4, \"text\": \"Share as picture failed\"},\n    {\"id\": 5, \"text\": \"Print PDF failed\"},\n    {\"id\": 6, \"text\": \"Insert password\"}\n  ]\n}",
        "output: {\n  \"translations\": [\n    {\"id\": 1, \"text\": \"Esportazione come PDF fallita\"},\n    {\"id\": 2, \"text\": \"Condivisione come PDF fallita\"},\n    {\"id\": 3, \"text\": \"Esportazione nella galleria fallita\"},\n    {\"id\": 4, \"text\": \"Condivisione come immagine fallita\"},\n    {\"id\": 5, \"text\": \"Stampa PDF fallita\"},\n    {\"id\": 6, \"text\": \"Inserisci la password\"}\n  ]\n}",
        "input: {\n  \"source_language\": \"en\",\n  \"target_language\": \"it\",\n  \"strings\": [\n    {\"id\": 1, \"text\": \"Export as PDF failed\"},\n    {\"id\": 2, \"text\": \"Share as PDF failed\"},\n    {\"id\": 3, \"text\": \"Export to gallery failed\"},\n    {\"id\": 4, \"text\": \"Share as picture failed\"},\n    {\"id\": 5, \"text\": \"Print PDF failed\"},\n    {\"id\": 6, \"text\": \"Insert password\"}\n  ]\n}",
        "output: {\n  \"translations\": [\n    {\"id\": 1, \"text\": \"Esportazione come PDF fallita\"},\n    {\"id\": 2, \"text\": \"Condivisione come PDF fallita\"},\n    {\"id\": 3, \"text\": \"Esportazione nella galleria fallita\"},\n    {\"id\": 4, \"text\": \"Condivisione come immagine fallita\"},\n    {\"id\": 5, \"text\": \"Stampa PDF fallita\"},\n    {\"id\": 6, \"text\": \"Inserisci la password\"}\n  ]\n}",
        f"input 2: {input_data}",
        "output 2: ",
    ])

    # Return the response content
    return response

import xml.etree.ElementTree as ET
import json
import copy

def generate_json_from_xml(source_language, target_language, xml_content):
    # Parse the XML content
    root = ET.fromstring(xml_content)

    # List to hold translatable strings
    strings_list = []
    # Dictionary to keep track of string positions and their attributes
    string_metadata = {}

    # Iterate through each 'string' element in the XML
    for i, string_elem in enumerate(root.findall('string')):
        # Check if the string is translatable
        translatable = string_elem.attrib.get('translatable', 'true').lower()
        if translatable != "false":
            text = string_elem.text
            if text:  # Only add non-None text
                strings_list.append({"id": i + 1, "text": text, "name": string_elem.attrib.get('name')})
                # Store the original attributes and position
                string_metadata[string_elem.attrib.get('name')] = {
                    'position': i,
                    'attributes': dict(string_elem.attrib)
                }

    # Create the JSON structure
    json_structure = {
        "source_language": source_language,
        "target_language": target_language,
        "strings": strings_list
    }

    return json_structure, string_metadata, root

def update_xml_with_translations(root, translations, string_metadata):
    # Create a deep copy of the root to preserve the original structure
    new_root = copy.deepcopy(root)

    # Create a mapping of original strings to translations
    translation_map = {}
    for orig, trans in zip(string_metadata.keys(), translations):
        translation_map[orig] = trans['text']  # Use the 'text' field for translation

    # Update the strings in the new XML
    for string_elem in new_root.findall('string'):
        original_name = string_elem.attrib.get('name')
        if original_name in translation_map:
            print(f"Updating '{original_name}' -> '{translation_map[original_name]}'")
            string_elem.text = translation_map[original_name]

    return new_root


def save_translated_xml(root, output_file):
    # Convert the ElementTree to a string with proper formatting
    xml_str = ET.tostring(root, encoding='unicode', method='xml')

    # Add the XML declaration and proper indentation
    formatted_xml = '<?xml version="1.0" encoding="utf-8"?>\n' + xml_str

    # Save to file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(formatted_xml)

def extract_translations_from_response(response):
    # Get the text content from the response
    response_text = response.candidates[0].content.parts[0].text

    # Remove the markdown code block markers if present
    response_text = response_text.replace('```json\n', '').replace('\n```', '')

    # Parse the JSON response
    response_json = json.loads(response_text)

    return response_json['translations']

def translate_xml_file(input_xml_path, output_xml_path, source_lang, target_lang, translation_function):
    # Read the input XML file
    with open(input_xml_path, 'r', encoding='utf-8') as f:
        xml_content = f.read()
    print("\nProcessing XML file...")

    # Generate JSON for translation
    json_input, string_metadata, root = generate_json_from_xml(source_lang, target_lang, xml_content)
    print("\nStrings to translate:", json_input["strings"])
    print("Number of strings to translate:", len(json_input["strings"]))

    if not json_input["strings"]:
        print("No strings to translate!")
        return

    # Get translations using the provided translation function
    print("\nCalling translation API...")
    response = translation_function(json.dumps(json_input))

    try:
        # Extract translations from the response
        translations = extract_translations_from_response(response)
        print("\nReceived translations:", translations)
        print("Number of translations received:", len(translations))

        # Print mapping of original to translated strings
        print("\nTranslation mapping:")
        for orig, trans in zip(json_input["strings"], translations):
            print(f"'{orig['name']}' -> '{trans['text']}'")

    except Exception as e:
        print("Error processing response:", e)
        print("Raw response:", response)
        raise

    # Update XML with translations
    translated_root = update_xml_with_translations(root, translations, string_metadata)

    # Save the translated XML
    save_translated_xml(translated_root, output_xml_path)
    print("\nTranslation completed. Output saved to:", output_xml_path)

# Function to test a single translation
def test_translation(text, source_lang, target_lang, translation_function):
    json_input = {
        "source_language": source_lang,
        "target_language": target_lang,
        "strings": [text]
    }
    response = translation_function(json.dumps(json_input))
    translations = extract_translations_from_response(response)
    return translations[0]

import os
import time

languages = ["vi", "fr", "de", "ko", "it"]

input_file = "/content/drive/MyDrive/Colab Notebooks/source/strings.xml"
output_dir = "/content/drive/MyDrive/Colab Notebooks/res"

for lang in languages:
    lang_dir = os.path.join(output_dir, f"values-{lang}")
    os.makedirs(lang_dir, exist_ok=True)
    output_file = os.path.join(lang_dir, "strings.xml")
    translate_xml_file(input_file, output_file, "en", lang, request)
    time.sleep(10)